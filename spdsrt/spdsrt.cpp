// spdsrt.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include "spdsrt.h"

int main()
{
    // set console output UTF-16
    int iRet = _setmode(_fileno(stdout), _O_U16TEXT);

    // get full command line
    LPWSTR commandLine = GetCommandLineW();

    // parse command line
    int argcp = 0;
    LPWSTR* argvp = CommandLineToArgvW(commandLine, &argcp);

    // do main function
    iRet = DoSpdsrt(argcp, argvp);

    // free argv memory
    LocalFree(argvp);

    return iRet;
}

struct stMeta g_Meta;
std::vector<std::unique_ptr<CSrtNode>> g_Srt;
bool g_bBracket = false;
bool g_bUpline = false;
bool g_bMonoline = false;
bool g_bKeepBlankLine = false;

bool g_bIsSrcAss = false;
bool g_bDiscardAssStyle = false;
bool g_bUseDefaultFont = false;
bool g_bAnimateOff = false;
bool g_bSortTimestamp = false;
bool g_bHasChn = false;

bool g_bCalMaxFrames = false;
bool g_bResizeAss = false;
bool g_bAdjust169 = false;

int g_iFontSizeIdx = 2;
int g_iEnFontClrIdx = 1;

size_t g_maxchCt = 30 * 2; /* Max CH Chars for a line */
size_t g_maxenCt = 85;     /* Max EN Chars for a line */

std::wstring g_szUsage =
L"\nChinese/English bi-language unified subtitle formatter v3.1.25, Copyright(c) 2012-2025 by XHBL."
L"\n"
L"\nUsage: spdsrt input.srt [-b] [-u] [-s] [-k] [-t]"
L"\n       spdsrt input.ass [-b] [-u] [-s] [-k] [-d] [-f] [-a] [-t] [-z<n>] [-c<n>]"
L"\n"
L"\n Input has to be a SRT/ASS file which contains Chinese/English bi-language content."
L"\n Output are 9 files include formatted Chinese-English, English-Chinese,"
L"\n Chinese, English SRT and ASS files (suffixed with .ce/.ec/.ch/.en/.or)."
L"\n"
L"\n  -b    Chinese only single line adding round Brackets"
L"\n  -u    Chinese only line(s) align Up-top in ASS"
L"\n  -s    Merge multiple lines to a Single line, Chinese/English respectively"
L"\n  -k    Keep empty line(s) for output"
L"\n  -d    Discard all input ASS styles and use built-in styles for output"
L"\n  -f    Use built-in Font style to overide input ASS font"
L"\n  -a    Animated styles from input ASS skipped for output"
L"\n  -t    Sort output by Timestamp"
L"\n  -z<n> SiZe of font, z1-small z2-medium(default) z3-large"
L"\n  -c<n> Color of English font, c1-yellow(default) c2-orange"
L"\n"
L"\nAux:   spdsrt input.ass -res<XXX>x<YYY>"
L"\n       spdsrt input.ass -169"
L"\n       spdsrt input.ass|srt -mf<FR>"
L"\n"
L"\n Some Auxiliary functions to adjust or check input ASS/SRT file."
L"\n"
L"\n  -res<Wx><H> Resize ASS resolution, <Wx> - width, <H> - height."
L"\n              Output file name suffixed with string .res"
L"\n              Example: -res512x288, -res288, -res512x"
L"\n  -169        Adjust wide screen(2.35:1) coordinates to 16:9 display."
L"\n              Output file name suffixed with string .169"
L"\n  -mf<FR>     Print Maximum frames by frame rate, <FR> - frame rate. "
L"\n              Example: -mf23.976, -mf25"
L"\n";


void InitMeta()
{
    g_Meta.iPlayResXDft = 512;
    g_Meta.iPlayResYDft = 288;
    g_Meta.iPlayResXSrc = 384;
    g_Meta.iPlayResYSrc = 288;
    g_Meta.szFontCh = L"SIMHEI";
    g_Meta.iFontCh = 16;
    g_Meta.iFontChCal = 16;
    g_Meta.szFontEn = L"Tahoma";
    g_Meta.iFontEn = 13;
    g_Meta.iFontEnCal = 13;
    g_Meta.szFontDft = L"Tahoma";
    g_Meta.iFontDft = 13;
    g_Meta.iFontDftCal = 13;
    g_Meta.iMarginL = 5;
    g_Meta.iMarginR = 5;
    g_Meta.iMarginV = 5;
    g_Meta.iMarginLCal = 5;
    g_Meta.iMarginRCal = 5;
    g_Meta.iMarginVCal = 5;
    g_Meta.iSlvCh = 12;
    g_Meta.iSlvChCal = 12;
    g_Meta.iSlvEn = 14;
    g_Meta.iSlvEnCal = 14;
    g_Meta.iEncodeCh = 134;
    g_Meta.iEncodeEn = 0;
    g_Meta.szStyleNameDft = L"Default";
    g_Meta.szStyleNameDftAlt = L"Regular";
    g_Meta.szStyleFmt = L"Style: %s,%s,%d,%s,&H00FFFFFF,&H00101010,&H80000000,-1,0,0,0,100,100,0,0,1,2,1,2,%d,%d,%d,%d";
    g_Meta.szStyleDftCh[0] = 0;
    g_Meta.szStyleDftEn[0] = 0;
    g_Meta.szStyleCalCh[0] = 0;
    g_Meta.szStyleCalEn[0] = 0;
    g_Meta.szAssHdrFmt =
        L"[Script Info]\r\n"
        L";Auto-Generated by SPDSRT\r\n"
        L";Copyright(C) 2010-2025 XHBL\r\n"
        L"\r\n"
        L"Title:\r\n"
        L"Original Script:\r\n"
        L"Original Translation:\r\n"
        L"Original Timing:\r\n"
        L"Original Editing:\r\n"
        L"Script Updated By:\r\n"
        L"Update Details:\r\n"
        L"ScriptType: v4.00+\r\n"
        L"Collisions: Normal\r\n"
        L"PlayResX: %d\r\n"
        L"PlayResY: %d\r\n"
        L"Timer: 100.0000\r\n"
        L"Synch Point: 0\r\n"
        L"WrapStyle: 0\r\n"
        L"ScaledBorderAndShadow: no\r\n"
        L"\r\n"
        L"[V4+ Styles]\r\n"
        L"Format: Name, Fontname, Fontsize, PrimaryColour, SecondaryColour, OutlineColour, BackColour, Bold, Italic, Underline, StrikeOut, ScaleX, ScaleY, Spacing, Angle, BorderStyle, Outline, Shadow, Alignment, MarginL, MarginR, MarginV, Encoding\r\n"
        L"%s\r\n"
        L"\r\n"
        L"[Events]\r\n"
        L"Format: Layer, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text\r\n";
    g_Meta.szAssHdrDftCh[0] = 0;
    g_Meta.szAssHdrDftEn[0] = 0;
    g_Meta.szAssHdrSrcCh[0] = 0;
    g_Meta.szAssHdrSrcEn[0] = 0;
    g_Meta.szAssHdrSrcOrg[0] = 0;
}

void UpdateMeta()
{
    float fZoom = static_cast<float>(g_Meta.iPlayResYSrc) / static_cast<float>(g_Meta.iPlayResYDft);
    if (g_bDiscardAssStyle) fZoom = 1.0f;

    switch (g_iFontSizeIdx)
    {
    case 1: g_Meta.iFontCh = 15; g_Meta.iFontEn = 12; g_Meta.iFontDft = 12; break;          // small
    case 3: g_Meta.iFontCh = 17; g_Meta.iFontEn = 14; g_Meta.iFontDft = 14; break;          // large
    case 2: default: g_Meta.iFontCh = 16; g_Meta.iFontEn = 13; g_Meta.iFontDft = 13; break; // medium
    }

    g_Meta.iFontChCal = static_cast<int>(std::round(fZoom * g_Meta.iFontCh));
    g_Meta.iFontEnCal = static_cast<int>(std::round(fZoom * g_Meta.iFontEn));
    g_Meta.iFontDftCal = static_cast<int>(std::round(fZoom * g_Meta.iFontDft));

    g_Meta.iSlvChCal = static_cast<int>(std::round(fZoom * g_Meta.iSlvCh));
    g_Meta.iSlvEnCal = static_cast<int>(std::round(fZoom * g_Meta.iSlvEn));

    g_Meta.iMarginLCal = static_cast<int>(std::round(fZoom * g_Meta.iMarginL));
    g_Meta.iMarginRCal = static_cast<int>(std::round(fZoom * g_Meta.iMarginR));
    g_Meta.iMarginVCal = static_cast<int>(std::round(fZoom * g_Meta.iMarginV));

    std::wstring szPrimColor;
    switch (g_iEnFontClrIdx)
    {
    case 2: szPrimColor = L"&H00007FFF"; break;             // orange
    case 1: default: szPrimColor = L"&H0000FFFF"; break;    // yellow
    }

    swprintf(g_Meta.szStyleDftCh, 256, g_Meta.szStyleFmt,
        g_Meta.szStyleNameDft, g_Meta.szFontDft, g_Meta.iFontDft, szPrimColor.c_str(),
        g_Meta.iMarginL, g_Meta.iMarginR, g_Meta.iMarginV, g_Meta.iEncodeCh);
    swprintf(g_Meta.szStyleDftEn, 256, g_Meta.szStyleFmt,
        g_Meta.szStyleNameDft, g_Meta.szFontDft, g_Meta.iFontDft, szPrimColor.c_str(),
        g_Meta.iMarginL, g_Meta.iMarginR, g_Meta.iMarginV, g_Meta.iEncodeEn);
    swprintf(g_Meta.szStyleCalCh, 256, g_Meta.szStyleFmt,
        g_Meta.szStyleNameDftAlt, g_Meta.szFontDft, g_Meta.iFontDftCal, szPrimColor.c_str(),
        g_Meta.iMarginLCal, g_Meta.iMarginRCal, g_Meta.iMarginVCal, g_Meta.iEncodeCh);
    swprintf(g_Meta.szStyleCalEn, 256, g_Meta.szStyleFmt,
        g_Meta.szStyleNameDftAlt, g_Meta.szFontDft, g_Meta.iFontDftCal, szPrimColor.c_str(),
        g_Meta.iMarginLCal, g_Meta.iMarginRCal, g_Meta.iMarginVCal, g_Meta.iEncodeEn);

    swprintf(g_Meta.szAssHdrDftCh, 4096, g_Meta.szAssHdrFmt,
        g_Meta.iPlayResXDft, g_Meta.iPlayResYDft, g_Meta.szStyleDftCh);
    swprintf(g_Meta.szAssHdrDftEn, 4096, g_Meta.szAssHdrFmt,
        g_Meta.iPlayResXDft, g_Meta.iPlayResYDft, g_Meta.szStyleDftEn);
}

void UpdateUsage()
{
    std::wstring strFname, strVer;
    if (GetFileVerStrW(strFname, strVer))
    {
        StrReplaceW(g_szUsage, L"spdsrt", strFname);
        StrReplaceW(g_szUsage, L"3.1.25", strVer);
    }
}

std::wstring TrimStyle(const wchar_t* szContent)
{
    std::wstring sR;
    if (szContent == nullptr || szContent[0] == 0)
        return sR;

    const wchar_t* pS = szContent;
    const wchar_t* pE = pS + wcslen(szContent);

    while (*pS)
    {
        if (*pS == L'<' && (pS + 2) < pE && *(pS + 2) == L'>')
        {
            pS += 3; // 跳过 "<x>" 格式的标签
        }
        else if (*pS == L'<' && (pS + 3) < pE && *(pS + 1) == L'/' && *(pS + 3) == L'>')
        {
            pS += 4; // 跳过 "</x>" 格式的标签
        }
        else if (*pS == L'{')
        {
            while (*++pS) // 跳过 "{...}" 格式的内容
            {
                if (*pS == L'}')
                {
                    pS++;
                    break;
                }
            }
        }
        else
        {
            sR += *pS;
            pS++;
        }
    }
    return sR;
}

size_t AnsiLen(const wchar_t* s)
{
    if (s == nullptr || s[0] == 0)
        return 0;

    std::wstring sc = TrimStyle(s);
    std::vector<char> buf(sc.length() * 2 + 2);
    // 将宽字符字符串转换为多字节字符串
    WStrToAnsi(buf.data(), sc.c_str());
    // 获取多字节字符串的长度
    size_t rl = strlen(buf.data());
    return rl;
}

std::wstring Ass2Srt(const wchar_t* lpSsa)
{
    std::wstring szSrt;
    if (!lpSsa || !lpSsa[0])
        return szSrt;

    static const wchar_t* sStyle[] = { L"b", L"i", L"u" };
    static int iStyle = sizeof(sStyle) / sizeof(const wchar_t*);

    std::wstring szSsa = lpSsa;
    for (int i = 0; i < iStyle; i++)
    {
        std::wstring szS1 = StrFormatW(L"\\%s0", sStyle[i]);
        std::wstring szD1 = StrFormatW(L"}</%s>{", sStyle[i]);
        std::wstring szS2 = StrFormatW(L"\\%s1", sStyle[i]);
        std::wstring szD2 = StrFormatW(L"}<%s>{", sStyle[i]);
        StrReplaceW(szSsa, szS1, szD1);
        StrReplaceW(szSsa, szS2, szD2);
    }

    const wchar_t* pS = szSsa.c_str();
    while (*pS)
    {
        if (*pS == L'{')
        {
            while (*++pS)
            {
                if (*pS == L'}')
                {
                    pS++;
                    break;
                }
            }
        }
        else
        {
            szSrt += *pS;
            pS++;
        }
    }

    for (int i = 0; i < iStyle; i++)
    {
        std::wstring szL = StrFormatW(L"<%s>", sStyle[i]);
        std::wstring szR = StrFormatW(L"</%s>", sStyle[i]);
        std::wstring szLR = szL + szR;

        size_t iFindL = szSrt.find(szL);
        size_t iFindR = szSrt.find(szR);
        if (iFindL != std::wstring::npos && iFindR == std::wstring::npos)
            szSrt += szR;
        else if (iFindR != std::wstring::npos && iFindL == std::wstring::npos)
            szSrt = szL + szSrt;
        else if (iFindL != std::wstring::npos && iFindR != std::wstring::npos && iFindL > iFindR)
            szSrt = szL + szSrt + szR;
        StrReplaceW(szSrt, szLR, L"");
    }

    std::wstring sTrim = TrimStyle(szSrt.c_str());
    if (sTrim.empty())
        return sTrim;

    return szSrt;
}

int AssTypeKeep(const wchar_t* lpAss)
{
    if (!lpAss || !lpAss[0])
        return 0;

    static const wchar_t* szAssKeepKey[] = {
      L"\\pos", L"\\move", L"\\t(",
    };
    static int iAssKeepKey = sizeof(szAssKeepKey) / sizeof(const wchar_t*);

    static const wchar_t* szAssKeepKey2[] = {
      L"\\a1", L"\\a2", L"\\a3", L"\\a4", L"\\a5",
      L"\\a6", L"\\a7", L"\\a8", L"\\a9", L"\\an",
    };
    static int iAssKeepKey2 = sizeof(szAssKeepKey2) / sizeof(const wchar_t*);

    std::wstring szAss(lpAss);
    for (int i = 0; i < iAssKeepKey; i++)
    {
        if (szAss.find(szAssKeepKey[i]) != std::wstring::npos)
            return 1;
    }
    for (int i = 0; i < iAssKeepKey2; i++)
    {
        if (szAss.find(szAssKeepKey2[i]) != std::wstring::npos)
            return 2;
    }
    return 0;
}

std::wstring AssTrimAnimation(const wchar_t* lpAss)
{
    std::wstring szAss;

    if (!lpAss || !lpAss[0])
        return szAss;

    static const wchar_t* szAssTA[] = {
      L"\\fad", L"\\move(", L"\\t(", L"\\k", L"\\K",
    };
    static wchar_t cDelim[] = { L'\\', L')', L')', L'\\', L'\\' };
    static int iAssTA = sizeof(szAssTA) / sizeof(const wchar_t*);

    szAss = lpAss;
    for (int i = 0; i < iAssTA; i++)
    {
        std::wstring szAssNew;
        int iFlen = wcslen(szAssTA[i]);
        size_t iFb = 0, iFe = 0, iFe2 = 0;

        while ((iFb = szAss.find(szAssTA[i], iFb)) != std::wstring::npos)
        {
            const wchar_t* lpFe = szAss.c_str() + iFb + iFlen;
            for (iFe = std::wstring::npos, iFe2 = std::wstring::npos;; lpFe++)
            {
                if (*lpFe == cDelim[i] || *lpFe == L'}' || *lpFe == 0)
                {
                    iFe = lpFe - szAss.c_str();
                    iFe2 = iFe;
                    if (*lpFe && *lpFe != L'}' && cDelim[i] != L'\\') iFe2++;
                    break;
                }
            }
            if (iFe >= iFb + iFlen)
            {
                std::wstring szScan = szAss.substr(iFb + iFlen, iFe - iFb - iFlen);
                StrTrimW(szScan, cDelim[i], 2); // TrimRight
                std::wstring szAssAlt;
                if (i == 1) // in case \move
                {
                    float fX1, fY1, fX2, fY2;
                    if (swscanf_s(szScan.c_str(), L"%f,%f,%f,%f", &fX1, &fY1, &fX2, &fY2) == 4)
                    {
                        int iMinY = 0;
                        int pX = static_cast<int>(std::round((fX1 + fX2) / 2));
                        int pY = static_cast<int>(std::round((fY1 + fY2) / 2));
                        if (fX1 <= 0)
                            pX = static_cast<int>(std::round(fX2));
                        if (fX2 <= 0)
                            pX = static_cast<int>(std::round(fX1));
                        if (fY1 <= iMinY)
                            pY = static_cast<int>(std::round(fY2));
                        if (fY2 <= iMinY)
                            pY = static_cast<int>(std::round(fY1));
                        szAssAlt = StrFormatW(L"\\pos(%d,%d)", pX, pY);
                    }
                }
                else if (i == 2) // in case \t
                {
                    std::wstring szTass = szAss.substr(iFb + iFlen, iFe - iFb - iFlen);
                    size_t iFn = szTass.find(L'\\');
                    if (iFn != std::wstring::npos)
                    {
                        szAssAlt = szTass.substr(iFn);
                        static const wchar_t* szFtm[] = {
                          L"\\fs0", L"\\fs1", L"\\fs2", L"\\alpha&FF&",
                        };
                        static int iFtm = sizeof(szFtm) / sizeof(const wchar_t*);
                        for (int t = 0; t < iFtm; t++)
                        {
                            int iFtl = wcslen(szFtm[t]);
                            size_t iFtn = szAssAlt.find(szFtm[t]);
                            if (iFtn != std::wstring::npos && (szAssAlt[iFtn + iFtl] == 0 || szAssAlt[iFtn + iFtl] == L'\\'))
                                szAssAlt.erase(iFtn, iFtl);
                        }
                    }
                }
                szAssNew += szAss.substr(0, iFb);
                szAssNew += szAssAlt;
            }
            szAss = szAss.substr(iFe2);
        }
        szAssNew += szAss;
        szAss = szAssNew;
    }

    StrReplaceW(szAss, L"{}", L"");
    return szAss;
}

int AssRcX(double fX, int mode, double fRX, double fRY)
{
    int iCal = static_cast<int>(std::round(fX));
    switch (mode)
    {
    case 0:
        iCal = static_cast<int>(std::round(fX * fRX));
        break;
    case 1:
        break;
    }
    return iCal;
}

int AssRcY(double fY, int mode, double fRX, double fRY)
{
    int iCal = static_cast<int>(std::round(fY));
    switch (mode)
    {
    case 0:
        iCal = static_cast<int>(std::round(fY * fRY));
        break;
    case 1:
        iCal = static_cast<int>(std::round(fY * 3 / 4 + g_Meta.iPlayResYSrc / 8.0));
        break;
    }
    return iCal;
}

int AssRcS(double fS, int mode, double fRX, double fRY)
{
    int iCal = static_cast<int>(std::round(fS));
    switch (mode)
    {
    case 0:
        iCal = static_cast<int>(std::round(fS * fRY));
        break;
    case 1:
        iCal = static_cast<int>(std::round(fS * 3 / 4));
        break;
    }
    if (fS > 0.0 && iCal == 0) iCal++;
    return iCal;
}

std::wstring AssRecal(const wchar_t* lpAss, int mode, double fRX, double fRY)
{
    std::wstring szAss;

    if (!lpAss || !lpAss[0])
        return szAss;

    static const wchar_t* szAssWT[] = {
      L"\\pos(", L"\\move(", L"\\org(", L"\\clip(", L"\\fsp", L"\\fs",
    };
    static wchar_t cDelim[] = { L')', L')', L')', L')', L'\\', L'\\' };
    static wchar_t cDelim2[] = { L')', L')', L')', L')', L')', L')' };
    static int iAssWT = sizeof(szAssWT) / sizeof(const wchar_t*);

    szAss = lpAss;
    for (int i = 0; i < iAssWT; i++)
    {
        std::wstring szAssNew;
        int iFlen = wcslen(szAssWT[i]);
        size_t iFb = 0, iFe = 0, iFe2 = 0;
        while ((iFb = szAss.find(szAssWT[i], iFb)) != std::wstring::npos)
        {
            const wchar_t* lpFe = szAss.c_str() + iFb + iFlen;
            for (iFe = std::wstring::npos, iFe2 = std::wstring::npos;; lpFe++)
            {
                if (*lpFe == cDelim[i] || *lpFe == cDelim2[i] || *lpFe == L'}' || *lpFe == 0)
                {
                    iFe = lpFe - szAss.c_str();
                    iFe2 = iFe;
                    if (*lpFe && *lpFe != L'}' && cDelim[i] != L'\\')
                        iFe2++;
                    break;
                }
            }
            if (iFe >= iFb + iFlen)
            {
                std::wstring szScan = szAss.substr(iFb + iFlen, iFe - iFb - iFlen);
                StrTrimW(szScan, cDelim[i], 2); // TrimRight
                std::wstring szAssAlt = szAss.substr(iFb, iFe - iFb);
                float fX1, fY1, fX2, fY2;
                int iScan = 0, iT1, iT2;
                switch (i)
                {
                case 0: // in case \pos
                case 2: // in case \org
                    iScan = swscanf_s(szScan.c_str(), L"%f,%f", &fX1, &fY1);
                    if (iScan == 2)
                    {
                        szAssAlt = StrFormatW(L"%s%d,%d%c", szAssWT[i],
                            AssRcX(fX1, mode, fRX, fRY), AssRcY(fY1, mode, fRX, fRY), cDelim[i]);
                    }
                    break;
                case 1: // in case \move
                case 3: // in case \clip
                    iScan = swscanf_s(szScan.c_str(), L"%f,%f,%f,%f,%d,%d", &fX1, &fY1, &fX2, &fY2, &iT1, &iT2);
                    if (iScan == 4)
                    {
                        szAssAlt = StrFormatW(L"%s%d,%d,%d,%d%c", szAssWT[i],
                            AssRcX(fX1, mode, fRX, fRY), AssRcY(fY1, mode, fRX, fRY),
                            AssRcX(fX2, mode, fRX, fRY), AssRcY(fY2, mode, fRX, fRY), cDelim[i]);
                    }
                    else if (iScan == 6)
                    {
                        szAssAlt = StrFormatW(L"%s%d,%d,%d,%d,%d,%d%c", szAssWT[i],
                            AssRcX(fX1, mode, fRX, fRY), AssRcY(fY1, mode, fRX, fRY),
                            AssRcX(fX2, mode, fRX, fRY), AssRcY(fY2, mode, fRX, fRY), iT1, iT2, cDelim[i]);
                    }
                    break;
                case 4: // in case \fsp
                    if (szScan[0] >= L'0' && szScan[0] <= L'9')
                    {
                        iScan = swscanf_s(szScan.c_str(), L"%f", &fX1);
                        if (iScan == 1)
                        {
                            int iFsp = AssRcX(fX1, mode, fRX, fRY);
                            szAssAlt = StrFormatW(L"%s%d", szAssWT[i], iFsp);
                        }
                    }
                    break;
                case 5: // in case \fs
                    if (szScan[0] >= L'0' && szScan[0] <= L'9')
                    {
                        iScan = swscanf_s(szScan.c_str(), L"%f", &fY1);
                        if (iScan == 1)
                        {
                            int iFs = AssRcS(fY1, mode, fRX, fRY);
                            szAssAlt = StrFormatW(L"%s%d", szAssWT[i], iFs);
                        }
                    }
                    break;
                }
                szAssNew += szAss.substr(0, iFb);
                szAssNew += szAssAlt;
            }
            szAss = szAss.substr(iFe2);
        }
        szAssNew += szAss;
        szAss = szAssNew;
    }

    return szAss;
}

std::wstring AssFontDft(const wchar_t* lpAss, int iLan)
{
    std::wstring szAss;

    if (!lpAss || !lpAss[0])
        return szAss;

    szAss = lpAss;

    std::wstring szFontDft;
    if (iLan == 1)
        szFontDft = g_Meta.szFontCh;
    else if (iLan == 2)
        szFontDft = g_Meta.szFontEn;
    else
        return szAss;

    std::wstring szAssFD;
    size_t iFb = 0, iFe = 0;
    while ((iFb = szAss.find(L"\\fn", iFb)) != std::wstring::npos)
    {
        const wchar_t* lpFe = szAss.c_str() + iFb + 3;
        for (iFe = std::wstring::npos;; lpFe++)
        {
            if (*lpFe == L'\\' || *lpFe == L'}' || *lpFe == 0)
            {
                iFe = lpFe - szAss.c_str();
                break;
            }
        }

        if (iFe > iFb + 3)
        {
            szAssFD += szAss.substr(0, iFb + 3);
            szAssFD += szFontDft;
        }
        szAss = szAss.substr(iFe);
    }

    szAssFD += szAss;
    return szAssFD;
}

std::wstring AssCheckMV(const wchar_t* lpAss, size_t charCount, int iLan)
{
    std::wstring szAss;

    if (!lpAss || !lpAss[0])
        return szAss;

    szAss = lpAss;

    size_t charCountMax = 0;
    int iSlv = 0;
    if (iLan == 1)
    {
        charCountMax = g_maxchCt;
        iSlv = g_Meta.iSlvChCal;
    }
    else if (iLan == 2)
    {
        charCountMax = g_maxenCt;
        iSlv = g_Meta.iSlvEnCal;
    }
    else
        return szAss;

    if (charCount > charCountMax)
        return szAss;

    std::wstring szMV = StrFormatW(L"%04d", iSlv);
    std::wstring szStyle;
    size_t iF1 = 0, iF2 = 0;
    for (int i = 0; i < 7; i++)
    {
        iF1 = szAss.find(L',', iF1);
        if (iF1 == std::wstring::npos) break;
        if (i == 3)
            szStyle = szAss.substr(iF2, iF1 - iF2);
        iF2 = ++iF1;
    }
    if (iF1 != std::wstring::npos)
    {
        iF2 = szAss.find(L',', iF1);
        if (iF2 != std::wstring::npos && std::wcstol((szAss.substr(iF1, iF2 - iF1)).c_str(), nullptr, 10) == 0)
        {
            int iStyleMV = 0;
            StrTrimW(szStyle);
            std::wstring szHdr(g_Meta.szAssHdrSrcOrg);
            size_t iFs = szHdr.find(szStyle + L',');
            if (iFs != std::wstring::npos)
            {
                iFs += szStyle.length();
                for (int i = 0; i < 21; i++, iFs++)
                {
                    iFs = szHdr.find(L',', iFs);
                    if (iFs == std::wstring::npos) break;
                }
                if (iFs != std::wstring::npos)
                {
                    size_t iFs2 = szHdr.find(L',', iFs);
                    if (iFs2 != std::wstring::npos)
                    {
                        iStyleMV = std::wcstol((szHdr.substr(iFs, iFs2 - iFs)).c_str(), nullptr, 10);
                    }
                }
            }
            if (iStyleMV < iSlv)
            {
                szAss.erase(iF1, iF2 - iF1);
                szAss.insert(iF1, szMV);
            }
        }
    }

    return szAss;
}

bool IsChSentence(const std::wstring& strSen)
{
    for (wchar_t wcEle : strSen)
    {
        if ((wcEle >= 0x4E00 && wcEle <= 0x9FA5) || // 基本汉字
            (wcEle >= 0xFF00 && wcEle <= 0xFFEF) || // 全角字符
            (wcEle >= 0x2E80 && wcEle <= 0x2EFF) || // 汉字扩展
            (wcEle >= 0x3000 && wcEle <= 0x303F) || // 标点符号
            (wcEle >= 0x31C0 && wcEle <= 0x31EF))   // 汉字扩展
        {
            return true;
        }
    }
    return false;
}

bool ChangeEnWithFWP(std::wstring& strRet, const std::wstring& strSen)
{
    const std::vector<std::pair<wchar_t, wchar_t>> wcPunct =
    {
      {L' ',  0x3000},  // 全角空格
      {L',',  0xFF0C},  // 全角逗号
      {L'.',  0xFF0E},  // 全角句号
      {L'.',  0x3002},  // 中文句号
      {L':',  0xFF1A},  // 全角冒号
      {L';',  0xFF1B},  // 全角分号
      {L'!',  0xFF01},  // 全角感叹号
      {L'?',  0xFF1F},  // 全角问号
      {L'\'', 0xFF07},  // 全角单引号
      {L'\'', 0x2018},  // 左单引号
      {L'\'', 0x2019},  // 右单引号
      {L'-',  0x2014},  // 中文破折号
      {L'-',  0xFF0D},  // 全角减号
      {L'-',  0xFF2D}   // 全角连字符
    };

    int nPuncNum = 0;
    int nEnNum = 0;
    std::wstring strTmp;
    for (wchar_t wcEle : strSen)
    {
        if ((wcEle >= 0x4E00 && wcEle <= 0x9FA5) ||
            (wcEle >= 0xFF00 && wcEle <= 0xFFEF) ||
            (wcEle >= 0x2E80 && wcEle <= 0x2EFF) ||
            (wcEle >= 0x3000 && wcEle <= 0x303F) ||
            (wcEle >= 0x31C0 && wcEle <= 0x31EF))
        {
            bool bPunctFound = false;
            for (const auto& punct : wcPunct)
            {
                if (punct.second == wcEle)
                {
                    strTmp += punct.first; // 替换为英文标点
                    nPuncNum++;
                    bPunctFound = true;
                    break;
                }
            }
            if (!bPunctFound)
            {
                strTmp += wcEle; // 保留原字符
            }
        }
        else
        {
            strTmp += wcEle;
            nEnNum++;
        }
    }

    if (nPuncNum + nEnNum == strSen.length())
    {
        strRet = strTmp;
        return true;
    }
    return false;
}

void AdjustSrt()
{
    // 标记重复的字幕节点
    struct SrtNodeKey // 辅助结构
    {
        std::wstring strTime;
        std::vector<std::wstring> astrCh;
        std::vector<std::wstring> astrEn;
        explicit SrtNodeKey(const CSrtNode& node) : strTime(node.strTime), astrCh(node.astrCh), astrEn(node.astrEn) {}
    };
    struct KeyHash // 哈希函数
    {
        size_t operator()(const SrtNodeKey& k) const
        {
            size_t seed = 0;
            seed ^= std::hash<std::wstring>()(k.strTime) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
            for (const auto& s : k.astrCh)
                seed ^= std::hash<std::wstring>()(s) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
            for (const auto& s : k.astrEn)
                seed ^= std::hash<std::wstring>()(s) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
            return seed;
        }
    };
    struct KeyEqual // 比较函数
    {
        bool operator()(const SrtNodeKey& a, const SrtNodeKey& b) const
        {
            return a.strTime == b.strTime && a.astrCh == b.astrCh && a.astrEn == b.astrEn;
        }
    };
    std::unordered_set<SrtNodeKey, KeyHash, KeyEqual> uniqueNodes;
    for (auto& node : g_Srt)
    {
        if (!node || node->bAssUnknown) continue;
        SrtNodeKey key(*node);
        if (uniqueNodes.count(key))
            node->bSrtDup = true;  // 标记重复项
        else
        {
            uniqueNodes.insert(key);
            node->bSrtDup = false;
        }
    }

    // 检测是否包含中文
    bool has_chline = false;
    for (const auto& srtNode : g_Srt)
    {

        if (srtNode && !srtNode->bAssUnknown && srtNode->astrCh.size() > 1)
        {
            has_chline = true;
            break;
        }
    }
    if (has_chline)
    {
        // 重复的英文分配给到中文
        for (auto& pNode : g_Srt)
        {
            if (!pNode || pNode->bAssUnknown || !pNode->astrCh.empty() || pNode->astrEn.size() < 2)
                continue;
            auto& enLines = pNode->astrEn;
            auto& chLines = pNode->astrCh;
            auto& enAssLines = pNode->astrAssEn;
            auto& chAssLines = pNode->astrAssCh;
            size_t patternLen = 0;
            const size_t enSize = enLines.size();
            for (size_t k = enSize / 2; k >= 1; --k)
            {
                if (enSize % k != 0) continue;
                bool validPattern = true;
                for (size_t i = k; i < enSize; ++i)
                {
                    if (enLines[i] != enLines[i % k])
                    {
                        validPattern = false;
                        break;
                    }
                }
                if (validPattern)
                {
                    patternLen = k;
                    break;
                }
            }
            if (patternLen == 0) continue;
            const size_t totalCycles = enSize / patternLen;
            const size_t moveCycles = totalCycles / 2;
            const size_t moveCount = moveCycles * patternLen;
            if (moveCount == 0) continue;
            // 移动重复行到中文
            chLines.assign(enLines.begin(), enLines.begin() + moveCount);
            enLines.erase(enLines.begin(), enLines.begin() + moveCount);
            chAssLines.assign(enAssLines.begin(), enAssLines.begin() + moveCount);
            enAssLines.erase(enAssLines.begin(), enAssLines.begin() + moveCount);
        }
    }

    // 单行中文加括号
    if (g_bBracket)
    {
        for (auto& pNode : g_Srt)
        {
            if (pNode && !pNode->bAssUnknown && pNode->astrEn.empty() &&
                (pNode->astrCh.size() == 1 || (pNode->astrCh.size() > 1 && g_bMonoline)))
            {
                size_t ln = pNode->astrCh.size();
                std::wstring sC1 = pNode->astrCh[0];
                std::wstring sC2 = pNode->astrCh[ln - 1];
                const wchar_t lb = L'\xFF08'; // 全角左括号
                const wchar_t rb = L'\xFF09'; // 全角右括号
                if (!sC1.empty() && sC1.front() != lb)
                    pNode->astrCh[0] = std::wstring(1, lb) + sC1;
                if (!sC2.empty() || sC2.back() != rb)
                    pNode->astrCh[ln - 1] += rb;
            }
        }
    }

    // 按时间码排序
    if (g_bSortTimestamp && !g_Srt.empty())
    {
        std::sort(g_Srt.begin(), g_Srt.end(),
            [](const auto& a, const auto& b) {
                return a->strTime < b->strTime;
            });
    }

    // 重置srt的行号
    int cline = 1;
    for (auto& pNode : g_Srt)
    {
        if (pNode && !pNode->bAssUnknown && !pNode->bSrtDup)
            pNode->nLine = cline++;
    }
}

void ParseSrt(const std::vector<std::wstring>& astrSrt, std::vector<unsigned int>& aiLan, std::unique_ptr<CSrtNode>& pSrtNode)
{
    if (astrSrt.empty()) return;

    aiLan.resize(astrSrt.size());
    for (size_t i = 0; i < astrSrt.size(); i++)
    {
        if (IsChSentence(astrSrt[i]))
        {
            pSrtNode->astrCh.push_back(astrSrt[i]);
            aiLan[i] = 1;
        }
        else
        {
            pSrtNode->astrEn.push_back(astrSrt[i]);
            aiLan[i] = 2;
        }
    }
    // 检测仅含中文标点的英文
    if (pSrtNode->astrCh.size() > 1 && pSrtNode->astrEn.empty())
    {
        pSrtNode->astrCh.clear();
        for (size_t i = 0; i < astrSrt.size(); i++)
        {
            std::wstring strTmp;
            if (ChangeEnWithFWP(strTmp, astrSrt[i]))
            {
                pSrtNode->astrEn.push_back(strTmp);
                aiLan[i] = 2;
            }
            else
            {
                pSrtNode->astrCh.push_back(astrSrt[i]);
                aiLan[i] = 1;
            }
        }
    }
    // 将原始内容保存到 astrOrg
    for (size_t i = 0; i < astrSrt.size(); i++)
        pSrtNode->astrOrg.push_back(astrSrt[i]);
}

int ReadSrt(const std::wstring& lpFn, std::wstring& szMsg)
{
    std::wstring fileContent;
    const size_t maxFileSize = 100 * 1024 * 1024; // 限制最大 100MB
    int readResult = ReadTextFileW(lpFn.c_str(), fileContent, maxFileSize);
    if (readResult != 0)
    {
        szMsg = StrFormatW(L"\nCan not read file %s\n", lpFn.c_str());
        return readResult;
    }

    std::wstring strLn, strTm;
    int nLn = 0;
    std::unique_ptr<CSrtNode> pSrtNode = nullptr;
    std::vector<std::wstring> astrSrt;
    std::vector<unsigned int> aiLan;
    size_t pos = 0;
    while (pos != std::wstring::npos)
    {
        strLn = strTm;
        pos = ReadOneLine(fileContent, strTm, pos);
        if (pos == std::wstring::npos && strTm.empty())
        {
            if (pSrtNode)
            {
                if (!astrSrt.empty())
                {
                    ParseSrt(astrSrt, aiLan, pSrtNode);
                    g_Srt.push_back(std::move(pSrtNode));
                }
            }
            break;
        }
        std::wstring sLtmp = strLn;
        StrTrimW(sLtmp);
        nLn = std::wcstol(sLtmp.c_str(), nullptr, 10);
        if ((nLn != 0 || sLtmp == L"0") && NumOfChars(strTm, L':') == 4 && strTm.find(L"-->") != std::wstring::npos)
        {
            if (pSrtNode)
            {
                astrSrt.pop_back();
                ParseSrt(astrSrt, aiLan, pSrtNode);
                g_Srt.push_back(std::move(pSrtNode));
                astrSrt.clear();
            }
            pSrtNode = std::make_unique<CSrtNode>();
            pSrtNode->nLine = nLn;
            pSrtNode->strTime = strTm;
            strTm.clear();
        }
        else if (!strTm.empty() && pSrtNode)
        {
            astrSrt.push_back(strTm);
        }
    }

    return 0;
}

void ParseAss(std::unique_ptr<CSrtNode>& pSrtNode)
{
    if (!pSrtNode || pSrtNode->strAssTxt.empty())
        return;

    const std::wstring cp = L"\\N";   // ASS 硬换行符
    const std::wstring cps = L"\\n";  // ASS 软换行符

    std::vector<std::wstring> astrAss;
    size_t startp = 0, endp = 0;
    while ((endp = pSrtNode->strAssTxt.find(cp, startp)) != std::wstring::npos)
    {
        std::wstring segment = pSrtNode->strAssTxt.substr(startp, endp - startp);
        StrReplaceW(segment, cps, L" "); // 替换 \n 为空格
        if (!segment.empty())
            astrAss.push_back(segment);
        startp = endp + cp.length();
    }
    std::wstring last_segment = pSrtNode->strAssTxt.substr(startp);
    StrReplaceW(last_segment, cps, L" ");
    if (!last_segment.empty())
        astrAss.push_back(last_segment);

    std::vector<std::wstring> astrSrt;
    std::vector<std::wstring> astrAss2;
    for (const auto& seg : astrAss)
    {
        std::wstring srt = Ass2Srt(seg.c_str());
        if (!srt.empty())
        {
            astrSrt.push_back(srt);
            astrAss2.push_back(seg);
        }
    }

    std::vector<unsigned int> aiLan;
    ParseSrt(astrSrt, aiLan, pSrtNode);
    pSrtNode->iAssKeep = AssTypeKeep(pSrtNode->strAssTxt.c_str());

    for (size_t i = 0; i < aiLan.size(); ++i)
    {
        std::wstring szAss = astrAss2[i];
        if (aiLan[i] == 1)
        {
            if (g_bUseDefaultFont)
                szAss = AssFontDft(szAss.c_str(), 1);
            pSrtNode->astrAssCh.push_back(szAss);
        }
        else if (aiLan[i] == 2)
        {
            if (g_bUseDefaultFont)
                szAss = AssFontDft(szAss.c_str(), 2);
            pSrtNode->astrAssEn.push_back(szAss);
        }
    }
}

size_t GetAssDlgPos(const std::wstring& szAss)
{
    size_t events_pos = StriFindW(szAss, L"[Events]");
    if (events_pos == std::wstring::npos) return events_pos;
    size_t format_pos = StriFindW(szAss, L"Format:", events_pos);
    if (format_pos == std::wstring::npos) return format_pos;
    std::wstring dummy_line;
    size_t after_format = ReadOneLine(szAss, dummy_line, format_pos);
    size_t current_pos = after_format;
    while (current_pos != std::wstring::npos)
    {
        std::wstring line;
        size_t next_pos = ReadOneLine(szAss, line, current_pos);
        if (line.find_first_not_of(L" \t\r\n") != std::wstring::npos)
            return current_pos;
        current_pos = next_pos;
    }
    return std::wstring::npos;
}

int GetAssHdr(std::wstring& szAss, std::wstring& szAssTxt, std::wstring& szMsg)
{
    const std::wstring szCRLF = L"\r\n";
    size_t iFind = GetAssDlgPos(szAss);
    if (iFind == std::wstring::npos)
    {
        szMsg = L"\nNo valid content in input file\n";
        return 1006;
    }
    std::wstring szHdr = szAss.substr(0, iFind);
    szAssTxt = szAss.substr(iFind);

    // get PlayRes
    int iPlayResX = 0, iPlayResY = 0;
    iFind = szHdr.find(L"PlayResX:");
    if (iFind != std::wstring::npos)
    {
        iFind += 9; // "PlayResX:" 长度
        size_t iFind2 = szHdr.find(szCRLF, iFind);
        if (iFind2 != std::wstring::npos)
        {
            std::wstring strX = szHdr.substr(iFind, iFind2 - iFind);
            iPlayResX = _wtoi(strX.c_str());
        }
    }
    iFind = szHdr.find(L"PlayResY:");
    if (iFind != std::wstring::npos)
    {
        iFind += 9; // "PlayResY:" 长度
        size_t iFind2 = szHdr.find(szCRLF, iFind);
        if (iFind2 != std::wstring::npos)
        {
            std::wstring strY = szHdr.substr(iFind, iFind2 - iFind);
            iPlayResY = _wtoi(strY.c_str());
        }
    }
    if (iPlayResX && iPlayResY)
    {
        g_Meta.iPlayResXSrc = iPlayResX;
        g_Meta.iPlayResYSrc = iPlayResY;
    }
    else if (!iPlayResY && iPlayResX)
    {
        g_Meta.iPlayResYSrc = g_Meta.iPlayResYSrc * iPlayResX / g_Meta.iPlayResXSrc;
        g_Meta.iPlayResXSrc = iPlayResX;
    }
    else if (!iPlayResX && iPlayResY)
    {
        g_Meta.iPlayResXSrc = g_Meta.iPlayResXSrc * iPlayResY / g_Meta.iPlayResYSrc;
        g_Meta.iPlayResYSrc = iPlayResY;
    }

    UpdateMeta();

    // Add new style
    iFind = StriFindW(szHdr, L"Styles]");
    if (iFind != std::wstring::npos)
    {
        iFind = StriFindW(szHdr, L"Format:", iFind);
        if (iFind != std::wstring::npos)
        {
            std::wstring dummyline;
            iFind = ReadOneLine(szHdr, dummyline, iFind);
        }
    }
    if (iFind != std::wstring::npos)
    {
        std::wstring szHdrCh = szHdr;
        std::wstring szHdrEn = szHdr;
        if (szHdrCh.find(g_Meta.szStyleCalCh) == std::wstring::npos)
            szHdrCh.insert(iFind, g_Meta.szStyleCalCh + szCRLF);
        if (szHdrEn.find(g_Meta.szStyleCalEn) == std::wstring::npos)
            szHdrEn.insert(iFind, g_Meta.szStyleCalEn + szCRLF);

        if (g_bUseDefaultFont)
        {
            std::wstring aszHdr[2] = { szHdrCh, szHdrEn };
            std::wstring szFontDft[2] = { g_Meta.szFontCh, g_Meta.szFontEn };
            std::wstring szFn[2] = { L"Style: Default,", L"Style:Default," };
            for (int i = 0; i < 2; ++i)
            {
                size_t iFn = StriFindW(aszHdr[i], szFn[0]);
                size_t iFlen = szFn[0].length();
                if (iFn == std::wstring::npos)
                {
                    iFn = StriFindW(aszHdr[i], szFn[1]);
                    iFlen = szFn[1].length();
                }
                if (iFn != std::wstring::npos)
                {
                    size_t iFe = aszHdr[i].find(L',', iFn + iFlen);
                    if (iFe != std::wstring::npos)
                    {
                        std::wstring szHdrL = aszHdr[i].substr(0, iFn + iFlen);
                        std::wstring szHdrR = aszHdr[i].substr(iFe);
                        aszHdr[i] = szHdrL + szFontDft[i] + szHdrR;
                    }
                }
            }
            szHdrCh = aszHdr[0];
            szHdrEn = aszHdr[1];
        }

        wcsncpy_s(g_Meta.szAssHdrSrcCh, 4096, szHdrCh.c_str(), _TRUNCATE);
        wcsncpy_s(g_Meta.szAssHdrSrcEn, 4096, szHdrEn.c_str(), _TRUNCATE);
        wcsncpy_s(g_Meta.szAssHdrSrcOrg, 4096, szHdr.c_str(), _TRUNCATE);
    }
    else
    {
        szMsg = L"\nCan not append refined style\n";
        return 1007;
    }

    return 0;
}

int GetAssTxt(std::wstring& szAssTxt, std::wstring& szMsg)
{
    const std::wstring event_types[] =
    {
      L"Dialogue:", L"Comment:", L"Command:",
      L"Sound:", L"Picture:", L"Movie:"
    }; // 事件类型列表（Dialogue为有效类型）

    size_t pos = 0;
    int iCountLine = 0;
    while (pos != std::wstring::npos)
    {
        std::wstring line;
        size_t next_pos = ReadOneLine(szAssTxt, line, pos);
        StrTrimW(line, nullptr, 1); // TrimLeft
        if (!line.empty())
        {
            auto pSrtNode = std::make_unique<CSrtNode>();
            pSrtNode->bAssUnknown = true;
            pSrtNode->nLine = 0;
            pSrtNode->strAssOrg = line;
            // 判断支持的事件类型
            bool is_support_type = false;
            size_t typelen = 0;
            for (const auto& type : event_types)
            {
                if (StriFindW(line, type) == 0) // 检查是否以支持的事件类型开头
                {
                    is_support_type = true;
                    typelen = type.length();
                    if (type == event_types[0]) // Dialogue为已知有效事件类型
                        pSrtNode->bAssUnknown = false;
                    break;
                }
            }
            // 支持的事件类型内容解析
            bool is_fmt_valid = true;
            if (is_support_type)
            {
                std::vector<std::wstring> szTxtSp;
                size_t iSpb = typelen, iSpe;
                for (int s = 0; s < 9; s++)
                {
                    iSpe = line.find(L',', iSpb);
                    if (iSpe != std::wstring::npos)
                    {
                        szTxtSp.push_back(line.substr(iSpb, iSpe - iSpb));
                        iSpb = iSpe + 1;
                    }
                    else
                    {
                        is_fmt_valid = false;
                        break;
                    }
                }
                // 解析时间码
                std::wstring szTxtMain, szTxtFmt;
                int iBtmH = 0, iBtmM = 0, iBtmS = 0, iBtmD = 0;
                int iEtmH = 0, iEtmM = 0, iEtmS = 0, iEtmD = 0;
                if (is_fmt_valid)
                {
                    szTxtMain = line.substr(iSpb);
                    szTxtFmt = line.substr(0, iSpb);
                    int iS1 = 0, iS2 = 0;
                    if (szTxtSp.size() > 1)
                        iS1 = swscanf_s(szTxtSp[1].c_str(), L"%d:%d:%d.%d", &iBtmH, &iBtmM, &iBtmS, &iBtmD);
                    if (szTxtSp.size() > 2)
                        iS2 = swscanf_s(szTxtSp[2].c_str(), L"%d:%d:%d.%d", &iEtmH, &iEtmM, &iEtmS, &iEtmD);
                    if (!(iS1 == 4 && iS2 == 4))
                        is_fmt_valid = false;
                    else if (!pSrtNode->bAssUnknown)
                        pSrtNode->nLine = ++iCountLine;
                }
                std::wstring strTm = StrFormatW(L"%02d:%02d:%02d,%03d --> %02d:%02d:%02d,%03d",
                    iBtmH, iBtmM, iBtmS, iBtmD * 10, iEtmH, iEtmM, iEtmS, iEtmD * 10);
                pSrtNode->strTime = strTm;
                if (is_fmt_valid)
                {
                    pSrtNode->strAssFmt = szTxtFmt;
                    pSrtNode->strAssTxt = szTxtMain;
                }
            }
            if (is_fmt_valid && !pSrtNode->bAssUnknown)
            {
                ParseAss(pSrtNode);
            }
            g_Srt.push_back(std::move(pSrtNode));
        }
        pos = next_pos;
    }
    return 0;
}

int ReadAss(const std::wstring& lpFn, std::wstring& szMsg)
{
    std::wstring fileContent;
    const size_t maxFileSize = 200 * 1024 * 1024; // 限制最大 200MB
    int readResult = ReadTextFileW(lpFn.c_str(), fileContent, maxFileSize);
    if (readResult != 0)
    {
        szMsg = StrFormatW(L"\nCan not read file %s\n", lpFn.c_str());
        return readResult;
    }

    std::wstring szAss = NormalizeToCRLF(fileContent);
    std::wstring szAssTxt;
    readResult = GetAssHdr(szAss, szAssTxt, szMsg);
    if (readResult)
        return readResult;

    readResult = GetAssTxt(szAssTxt, szMsg);
    return readResult;
}

bool SkipSrtLine(const std::unique_ptr<CSrtNode>& pSrtNode, osfMode mode)
{
    if (!pSrtNode) return true;
    bool isSrtMode = (mode >= or_srt) && (mode <= ch_srt);
    if (pSrtNode->bAssUnknown) return isSrtMode ? true : false;
    if (pSrtNode->bSrtDup && isSrtMode) return true;
    if (g_bKeepBlankLine) return false;

    switch (mode)
    {
    case or_srt:
        return pSrtNode->astrOrg.empty();
    case ec_srt: case ce_srt: case ec_ass: case ce_ass:
        return pSrtNode->astrEn.empty() && pSrtNode->astrCh.empty();
    case en_srt: case en_ass:
        return pSrtNode->astrEn.empty();
    case ch_srt: case ch_ass:
        return pSrtNode->astrCh.empty();
    default: return false;
    }
}

bool WriteSrtLine(std::ofstream& ofs, std::unique_ptr<CSrtNode>& pSrtNode, osfMode mode)
{
    if (SkipSrtLine(pSrtNode, mode)) return true;

    const std::wstring szCRLF = L"\r\n";
    // 行号时间码
    std::wstring header = std::to_wstring(pSrtNode->nLine) + szCRLF + pSrtNode->strTime + szCRLF;
    ofs << WStrToUtf8(header.c_str());

    // 内容生成lambda
    auto buildContent = [&szCRLF](const auto& lines, bool bMonoline)
        {
            std::wstring s;
            for (size_t i = 0; i < lines.size(); ++i)
            {
                s += lines[i];
                s += (bMonoline && i < lines.size() - 1) ? L" " : szCRLF;
            }
            return s;
        };
    const bool bMono = g_bMonoline;
    const auto& en = buildContent(pSrtNode->astrEn, bMono);
    const auto& ch = buildContent(pSrtNode->astrCh, bMono);
    const auto& org = buildContent(pSrtNode->astrOrg, bMono);

    // 不同输出模式组合
    std::wstring content;
    switch (mode)
    {
    case or_srt: content = org;     break;
    case ec_srt: content = en + ch; break;
    case ce_srt: content = ch + en; break;
    case en_srt: content = en;      break;
    case ch_srt: content = ch;      break;
    }

    // 写入内容
    content += szCRLF;
    ofs << WStrToUtf8(content.c_str());
    return ofs.good();
}

std::wstring TmSrt2Ass(const std::wstring& sTmSrt)
{
    int hh = 0, mm = 0, ss = 0, ms = 0;
    if (swscanf_s(sTmSrt.c_str(), L"%d:%d:%d,%d", &hh, &mm, &ss, &ms) != 4)
        return L"";
    return StrFormatW(L"%d:%02d:%02d.%02d", hh, mm, ss, ms / 10);
}

std::wstring FmSrt2Ass(const std::wstring& sFmSrt)
{
    std::wstring sFmAss = sFmSrt;
    StrReplaceW(sFmAss, L"</b>", L"{\\b0}");
    StrReplaceW(sFmAss, L"</B>", L"{\\b0}");
    StrReplaceW(sFmAss, L"<b>", L"{\\b1}");
    StrReplaceW(sFmAss, L"<B>", L"{\\b1}");
    StrReplaceW(sFmAss, L"</i>", L"{\\i0}");
    StrReplaceW(sFmAss, L"</I>", L"{\\i0}");
    StrReplaceW(sFmAss, L"<i>", L"{\\i1}");
    StrReplaceW(sFmAss, L"<I>", L"{\\i1}");
    StrReplaceW(sFmAss, L"</u>", L"{\\u0}");
    StrReplaceW(sFmAss, L"</U>", L"{\\u0}");
    StrReplaceW(sFmAss, L"<u>", L"{\\u1}");
    StrReplaceW(sFmAss, L"<U>", L"{\\u1}");
    return sFmAss;
}
std::wstring PrefixAss(std::unique_ptr<CSrtNode>& pSrtNode, size_t idx, int iLan)
{
    std::wstring szPA;
    if (!pSrtNode) return szPA;

    std::wstring szAss;
    if (iLan == 1 && idx < pSrtNode->astrAssCh.size())
        szAss = pSrtNode->astrAssCh[idx];
    if (iLan == 2 && idx < pSrtNode->astrAssEn.size())
        szAss = pSrtNode->astrAssEn[idx];

    if (szAss.empty()) return szPA;

    static const std::array<const wchar_t*, 3> szRP =
    {
        L"\\org", L"\\clip", L"\\fad"
    };

    std::wstring szPrefix;
    for (size_t i = 1; i < szRP.size(); ++i)
    {
        const auto& tag = szRP[i];
        size_t tagLen = wcslen(tag);
        size_t pos = szAss.find(tag);
        if (pos == std::wstring::npos)
            continue;
        size_t endPos = pos + tagLen;
        while (endPos < szAss.size() && szAss[endPos] != L'\\' && szAss[endPos] != L'}')
            ++endPos;
        szPrefix += szAss.substr(pos, endPos - pos);
    }
    if (!szPrefix.empty())
    {
        szPA = L"{" + szPrefix + L"}";
        if (g_bAnimateOff)
            szPA = AssTrimAnimation(szPA.c_str());
    }

    return szPA;
}

bool WriteAssSrcLine(std::ofstream& ofs, std::unique_ptr<CSrtNode>& pSrtNode, osfMode mode)
{
    if (SkipSrtLine(pSrtNode, mode)) return true;

    const std::wstring szCRLF = L"\r\n";
    const std::wstring szCP = L"\\N";
    const std::wstring szRt = L"{\\r}";
    const std::wstring szFtEn = StrFormatW(L"{\\fn%s}", g_Meta.szFontEn);

    std::wstring strWt;
    if (pSrtNode->bAssUnknown)
    {
        strWt = pSrtNode->strAssOrg;
    }
    else if (pSrtNode->iAssKeep != 0)
    {
        int iFirstLan = 1;
        if (!pSrtNode->astrAssCh.empty() && pSrtNode->strAssTxt.find(pSrtNode->astrAssCh[0]) == 0)
            iFirstLan = 1;
        if (!pSrtNode->astrAssEn.empty() && pSrtNode->strAssTxt.find(pSrtNode->astrAssEn[0]) == 0)
            iFirstLan = 2;

        size_t chLines = pSrtNode->astrCh.size();
        size_t enLines = pSrtNode->astrEn.size();
        size_t chChars = 0, enChars = 0;

        std::wstring szAssCh, szAssEn;
        for (size_t i = 0; i < pSrtNode->astrAssCh.size(); ++i)
        {
            const wchar_t* pAss = pSrtNode->astrAssCh[i].c_str();
            szAssCh += g_bAnimateOff ? AssTrimAnimation(pAss) : pAss;
            if (i != pSrtNode->astrAssCh.size() - 1) szAssCh += szCP;
            chChars += AnsiLen(pSrtNode->astrCh[i].c_str());
        }
        for (size_t i = 0; i < pSrtNode->astrAssEn.size(); ++i)
        {
            const wchar_t* pAss = pSrtNode->astrAssEn[i].c_str();
            szAssEn += g_bAnimateOff ? AssTrimAnimation(pAss) : pAss;
            if (i != pSrtNode->astrAssEn.size() - 1) szAssEn += szCP;
            enChars += AnsiLen(pSrtNode->astrEn[i].c_str());
        }

        strWt = pSrtNode->strAssFmt;
        std::wstring strMid, strReset, strFtEn;
        if (!szAssEn.empty()) strFtEn = szFtEn;
        switch (mode)
        {
        case ec_ass:
            if (iFirstLan == 1) strReset = szRt;
            if (!pSrtNode->astrCh.empty() && !pSrtNode->astrEn.empty())
                strMid = strReset + szCP;
            strWt += strFtEn + szAssEn + strMid + szAssCh;
            break;
        case ce_ass:
            if (iFirstLan == 2) strReset = szRt;
            if (!pSrtNode->astrCh.empty() && !pSrtNode->astrEn.empty())
                strMid = strReset + szCP;
            strWt += szAssCh + strMid + strFtEn + szAssEn;
            break;
        case en_ass:
            chLines = 0; chChars = 0; strWt += strFtEn + szAssEn;
            break;
        case ch_ass:
            enLines = 0; enChars = 0; strWt += szAssCh;
            break;
        }
        if (pSrtNode->iAssKeep == 2)
        {
            if (chLines == 1 && enLines == 0)
                strWt = AssCheckMV(strWt.c_str(), chChars, 1);
            else if (chLines == 0 && enLines == 1)
                strWt = AssCheckMV(strWt.c_str(), enChars, 2);
        }
    }
    // 写入行
    if (!strWt.empty())
    {
        strWt += szCRLF;
        ofs << WStrToUtf8(strWt.c_str());
    }
    return ofs.good();
}

bool WriteAssLine(std::ofstream& ofs, std::unique_ptr<CSrtNode>& pSrtNode, osfMode mode)
{
    if (!pSrtNode) return true;

    if (g_bIsSrcAss && !g_bDiscardAssStyle && (pSrtNode->iAssKeep || pSrtNode->bAssUnknown))
        return WriteAssSrcLine(ofs, pSrtNode, mode);

    if (SkipSrtLine(pSrtNode, mode)) return true;

    const std::wstring szCRLF = L"\r\n";
    const std::wstring sMVTag = L"_MV_";

    const size_t timeSepPos = pSrtNode->strTime.find(L"-->");
    if (timeSepPos == std::wstring::npos) return false;
    std::wstring sTm1 = pSrtNode->strTime.substr(0, timeSepPos);
    StrTrimW(sTm1, nullptr, 0);
    std::wstring sTm2 = pSrtNode->strTime.substr(timeSepPos + 3);
    StrTrimW(sTm2, nullptr, 0);

    std::wstring assStart = TmSrt2Ass(sTm1);
    std::wstring assEnd = TmSrt2Ass(sTm2);
    if (assStart.empty() || assEnd.empty()) return false;

    std::wstring styleName = g_Meta.szStyleNameDft;
    if (g_bIsSrcAss && !g_bDiscardAssStyle)
        styleName = g_Meta.szStyleNameDftAlt;

    std::wstring strWt = StrFormatW(L"Dialogue: 0,%s,%s,%s,,0000,0000,%s,,",
        assStart.c_str(), assEnd.c_str(), styleName.c_str(), sMVTag.c_str());

    std::wstring strCfmt = StrFormatW(L"{\\fnSIMHEI\\fs%d\\1c&HFFFFFF&}", g_Meta.iFontChCal);
    if (g_bUpline && pSrtNode->astrEn.empty())
        strCfmt = L"{\\an8}" + strCfmt;

    size_t chLines = pSrtNode->astrCh.size();
    size_t enLines = pSrtNode->astrEn.size();
    if (g_bMonoline)
    {
        if (chLines > 0) chLines = 1;
        if (enLines > 0) enLines = 1;
    }

    size_t chChars = 0, enChars = 0;
    const std::wstring str_CR = g_bMonoline ? L" " : L"\\N";
    std::wstring strCh, strEn;
    // 中文内容处理
    for (size_t i = 0; i < pSrtNode->astrCh.size(); ++i)
    {
        if (i == 0) strCh += strCfmt;
        strCh += PrefixAss(pSrtNode, i, 1) + FmSrt2Ass(pSrtNode->astrCh[i]);
        chChars += AnsiLen(pSrtNode->astrCh[i].c_str());
        if (i < pSrtNode->astrCh.size() - 1)
        {
            chChars++;
            strCh += str_CR;
        }
    }
    // 英文内容处理
    for (size_t i = 0; i < pSrtNode->astrEn.size(); ++i)
    {
        strEn += PrefixAss(pSrtNode, i, 2) + FmSrt2Ass(pSrtNode->astrEn[i]);
        enChars += AnsiLen(pSrtNode->astrEn[i].c_str());
        if (i < pSrtNode->astrEn.size() - 1)
        {
            enChars++;
            strEn += str_CR;
        }
    }
    // 不同输出模式组合
    std::wstring strMid;
    switch (mode) {
    case ec_ass:
        if (!pSrtNode->astrCh.empty() && !pSrtNode->astrEn.empty())
            strMid = L"\\N";
        strWt += strEn + strMid + strCh;
        break;
    case ce_ass:
        if (!pSrtNode->astrEn.empty() && !pSrtNode->astrCh.empty())
            strMid = L"{\\r}\\N";
        strWt += strCh + strMid + strEn;
        break;
    case en_ass:
        chLines = 0; chChars = 0; strWt += strEn;
        break;
    case ch_ass:
        enLines = 0; enChars = 0; strWt += strCh;
        break;
    }
    // 替换_MV_占位符
    std::wstring slvCh = StrFormatW(L"%04d", g_Meta.iSlvChCal);
    std::wstring slvEn = StrFormatW(L"%04d", g_Meta.iSlvEnCal);
    if (chLines == 1 && enLines == 0 && chChars <= g_maxchCt)
        StrReplaceW(strWt, sMVTag, slvCh);
    else if (chLines == 0 && enLines == 1 && enChars <= g_maxenCt)
        StrReplaceW(strWt, sMVTag, slvEn);
    else
        StrReplaceW(strWt, sMVTag, L"0000");
    // 写入行
    if (!strWt.empty())
    {
        strWt += szCRLF;
        ofs << WStrToUtf8(strWt.c_str());
    }
    return ofs.good();
}

bool WriteAssHdr(std::ofstream& ofs, bool bEn)
{
    const wchar_t* lpWt = nullptr;
    if (g_bIsSrcAss && !g_bDiscardAssStyle)
        lpWt = bEn ? g_Meta.szAssHdrSrcEn : g_Meta.szAssHdrSrcCh;
    else
        lpWt = bEn ? g_Meta.szAssHdrDftEn : g_Meta.szAssHdrDftCh;

    ofs << WStrToUtf8(lpWt);
    return ofs.good();
}

std::wstring ResizeAssHdr(double fRX, double fRY)
{
    std::wstring szHdr;
    const int resX = g_bAdjust169 ? g_Meta.iPlayResXSrc : static_cast<int>(std::round(fRX * g_Meta.iPlayResXSrc));
    const int resY = g_bAdjust169 ? g_Meta.iPlayResYSrc : static_cast<int>(std::round(fRY * g_Meta.iPlayResYSrc));
    const std::wstring szLnPxy = StrFormatW(L"PlayResX: %d\r\nPlayResY: %d", resX, resY);

    bool bSetRes = false;
    const wchar_t* pFn = g_Meta.szAssHdrSrcOrg;
    while (*pFn)
    {
        std::wstring szLn;
        while (*pFn && *pFn != L'\n') szLn += *pFn++;
        if (*pFn) szLn += *pFn++;
        // Style缩放
        size_t iFn = szLn.find(L"Style:");
        if (iFn != std::wstring::npos)
        {
            std::wstring szOp = szLn.substr(0, iFn + 6); // "Style:"长度6
            int iFs = iFn + 6;
            int iFnComma = iFs;
            for (int i = 0; i < 22; ++i)
            {
                size_t commaPos = szLn.find(L',', iFnComma);
                if (commaPos == std::wstring::npos) break;
                std::wstring szCal = szLn.substr(iFs, commaPos - iFs);
                int iCal = _wtoi(szCal.c_str());
                if (i == 2) // Font size
                {
                    if (iCal) szCal = StrFormatW(L"%d", static_cast<int>(std::round(iCal * fRY)));
                }
                else if (i == 21) // MarginV
                {
                    if (iCal) szCal = StrFormatW(L"%d", g_bAdjust169 ? iCal : static_cast<int>(std::round(iCal * fRY)));
                }
                else if (i == 13 || i == 19 || i == 20) // Spacing/MarginL/MarginR
                {
                    if (iCal) szCal = StrFormatW(L"%d", static_cast<int>(std::round(iCal * fRX)));
                }
                szOp += szCal + L',';
                iFs = commaPos + 1;
                iFnComma = iFs;
            }
            szOp += szLn.substr(iFs);
            szLn = szOp;
        }
        // 分辨率缩放
        if (szLn.find(L"PlayResX:") != std::wstring::npos || szLn.find(L"PlayResY:") != std::wstring::npos)
        {
            if (!bSetRes)
            {
                szHdr += szLnPxy + L"\r\n";
                bSetRes = true;
            }
            continue;
        }
        szHdr += szLn;
    }
    if (!bSetRes)
    {
        // 补充缺失的分辨率设置
        size_t v4Pos = szHdr.find(L"\n[V4");
        if (v4Pos != std::wstring::npos)
        {
            while (v4Pos > 0 && (szHdr[v4Pos] == L'\r' || szHdr[v4Pos] == L'\n')) v4Pos--;
            szHdr.insert(v4Pos + 1, L"\r\n" + szLnPxy);
        }
    }
    return szHdr;
}

std::wstring ResizeAssTxt(double fRX, double fRY)
{
    std::wstring szTxt;
    for (const auto& pSrt : g_Srt)
    {
        if (!pSrt) continue;
        if (pSrt->bAssUnknown && pSrt->strAssFmt.empty())
        {
            szTxt += pSrt->strAssOrg;
        }
        else
        {
            std::wstring szFmt = pSrt->strAssFmt;
            std::wstring szOp;
            size_t iFs = 0;
            size_t iFn = iFs;

            for (int i = 0; i < 9; ++i)
            {
                iFn = szFmt.find(L',', iFn);
                if (iFn == std::wstring::npos) break;
                std::wstring szCal = szFmt.substr(iFs, iFn - iFs);
                int iCal = _wtoi(szCal.c_str());
                if (i == 7) // MarginV
                {
                    if (iCal) szCal = StrFormatW(L"%d", AssRcY(iCal, g_bAdjust169 ? 1 : 0, fRX, fRY));
                }
                else if (i == 5 || i == 6) // MarginL/R
                {
                    if (iCal) szCal = StrFormatW(L"%d", static_cast<int>(std::round(iCal * fRX)));
                }
                szOp += szCal + L',';
                iFs = ++iFn;;
            }
            szOp += szFmt.substr(iFs);
            szTxt += szOp;
            szTxt += AssRecal(pSrt->strAssTxt.c_str(), g_bAdjust169 ? 1 : 0, fRX, fRY);
        }
        szTxt += L"\r\n";
    }

    return szTxt;
}

int ResizeAss(const std::wstring& lpFnRes, int iRRX, int iRRY, std::wstring& szRetMsg)
{
    if (lpFnRes.empty() || !g_bIsSrcAss)
    {
        szRetMsg = StrFormatW(L"\nInput must be a ASS file\n");
        return 1008;
    }
    if (iRRX == 0 && iRRY == 0)
    {
        szRetMsg = StrFormatW(L"\nInvalid resize number\n");
        return 1009;
    }

    // 计算缩放因子
    double fRX = 1.0, fRY = 1.0;
    if (iRRX) fRX = static_cast<double>(iRRX) / g_Meta.iPlayResXSrc;
    if (iRRY) fRY = static_cast<double>(iRRY) / g_Meta.iPlayResYSrc;
    if (!iRRX) fRX = fRY;
    if (!iRRY) fRY = fRX;

    // 生成写入内容
    const std::wstring content = ResizeAssHdr(fRX, fRY) + ResizeAssTxt(fRX, fRY);
    const std::string utf8Content = WStrToUtf8(content.c_str());

    // 写入文件
    std::ofstream ofs(lpFnRes, std::ios::binary);
    if (!ofs)
    {
        szRetMsg = StrFormatW(L"\nCan not write to file %s\n", lpFnRes.c_str());
        return 1000;
    }
    const unsigned char bom[] = { 0xEF, 0xBB, 0xBF }; // UTF-8 BOM
    ofs.write(reinterpret_cast<const char*>(bom), sizeof(bom));
    ofs.write(utf8Content.data(), utf8Content.size());
    bool ofsopr = ofs.good();
    ofs.close();
    if (!ofsopr)
    {
        szRetMsg = StrFormatW(L"\nCan not write ass content to file %s\n", lpFnRes.c_str());
        return 1001;
    }
    return 0;
}

int CalMaxFrames(double dFPS)
{
    int maxMilliseconds = 0;
    for (const auto& pNode : g_Srt)
    {
        if (!pNode) continue;
        const std::wstring& timeStr = pNode->strTime;
        const size_t arrowPos = timeStr.find(L"-->");
        if (arrowPos == std::wstring::npos) continue;
        // 分割时间区间
        std::wstring startTime = timeStr.substr(0, arrowPos);
        std::wstring endTime = timeStr.substr(arrowPos + 3);
        StrTrimW(startTime, nullptr, 0);
        StrTrimW(endTime, nullptr, 0);

        // 时间解析
        auto parseTime = [](const std::wstring& str) -> int {
            int hh = 0, mm = 0, ss = 0, ms = 0;
            if (swscanf_s(str.c_str(), L"%d:%d:%d,%d", &hh, &mm, &ss, &ms) == 4) {
                return (((hh * 60) + mm) * 60 + ss) * 1000 + ms;
            }
            return -1;
            };
        const int startMs = parseTime(startTime);
        const int endMs = parseTime(endTime);
        if (startMs == -1 || endMs == -1) continue;
        maxMilliseconds = std::max<int>({ maxMilliseconds, startMs, endMs });
    }
    return static_cast<int>(maxMilliseconds * dFPS / 1000.0) + 10;
}


int OutputSubFiles(const std::wstring& strFnMain, std::wstring& szRetMsg)
{
    struct WriteFileConfig { std::wstring fext; osfMode osf_mode; bool is_ass; bool is_eng; };
    const std::vector<WriteFileConfig> wfile_configs =
    {
      {L".or.srt", or_srt, false, false},
      {L".ch.srt", ch_srt, false, false},
      {L".en.srt", en_srt, false, true},
      {L".ce.srt", ce_srt, false, false},
      {L".ec.srt", ec_srt, false, false},
      {L".ch.ass", ch_ass, true, false},
      {L".en.ass", en_ass, true, true},
      {L".ce.ass", ce_ass, true, false},
      {L".ec.ass", ec_ass, true, false}
    };

    // 生成输出文件名并初始化文件流
    std::vector<std::tuple<std::ofstream, std::wstring, osfMode, bool, bool>> wfiles;
    for (const auto& cfg : wfile_configs)
    {
        auto filename = strFnMain + cfg.fext;
        std::ofstream wfile(filename, std::ios::binary);
        if (wfile)
        {
            const unsigned char bom[] = { 0xEF, 0xBB, 0xBF }; // UTF-8 BOM
            wfile.write(reinterpret_cast<const char*>(bom), sizeof(bom));
            wfiles.emplace_back(std::move(wfile), filename, cfg.osf_mode, cfg.is_ass, cfg.is_eng);
        }
        else
        {
            szRetMsg = StrFormatW(L"\nCan not write to file %s\n", filename.c_str());
            return 1000;
        }
    }
    // 写ASS文件头
    for (auto& entry : wfiles)
    {
        auto& wfile = std::get<0>(entry); // 获取流对象引用
        auto fname = std::get<1>(entry);
        bool is_ass = std::get<3>(entry);
        bool is_eng = std::get<4>(entry);
        if (is_ass)
        {
            if (!WriteAssHdr(wfile, is_eng))
            {
                szRetMsg = StrFormatW(L"\nCan not write ass header info to file %s\n", fname.c_str());
                return 1002;
            }
        }
    }
    // 写每个字幕节点
    for (auto& node : g_Srt)
    {
        for (auto& entry : wfiles)
        {
            auto& wfile = std::get<0>(entry);
            auto fname = std::get<1>(entry);
            osfMode mode = std::get<2>(entry);
            bool is_ass = std::get<3>(entry);
            bool is_eng = std::get<4>(entry);
            if (wfile)
            {
                if (is_ass)
                {
                    if (!WriteAssLine(wfile, node, mode))
                    {
                        szRetMsg = StrFormatW(L"\nCan not write ass lines to file %s\n", fname.c_str());
                        return 1003;
                    }
                }
                else
                {
                    if (!WriteSrtLine(wfile, node, mode))
                    {
                        szRetMsg = StrFormatW(L"\nCan not write srt lines to file %s\n", fname.c_str());
                        return 1005;
                    }
                }
            }
        }
    }
    return 0;
}

// core function
int DoSpdsrt(int argc, wchar_t* argv[])
{
    InitMeta();
    UpdateUsage();

    if (argc < 2)
    {
        wprintf(L"%s", g_szUsage.c_str());
        return 1;
    }

    double dFPS = 0.0;
    if (argc == 3 && std::wstring(argv[2]).find(L"-mf") == 0)
    {
        std::wstring szFR = std::wstring(argv[2]).substr(3);
        dFPS = std::wcstod(szFR.c_str(), nullptr);
        if (dFPS != 0.0)
            g_bCalMaxFrames = true;
    }

    int iRRX = g_Meta.iPlayResXSrc;
    int iRRY = g_Meta.iPlayResYSrc;
    if (argc == 3 && std::wstring(argv[2]).find(L"-res") == 0)
    {
        std::wstring szRR = std::wstring(argv[2]).substr(4);
        if (!szRR.empty())
        {
            std::wstring szRRX, szRRY = szRR;
            size_t iRR = szRR.find(L'x');
            if (iRR != std::wstring::npos)
            {
                szRRX = szRR.substr(0, iRR);
                szRRY = szRR.substr(iRR + 1);
            }
            iRRX = szRRX.empty() ? 0 : std::wcstol(szRRX.c_str(), nullptr, 10);
            iRRY = szRRY.empty() ? 0 : std::wcstol(szRRY.c_str(), nullptr, 10);
            if (!((iRRX == 0 && !szRRX.empty()) || (iRRY == 0 && !szRRY.empty()) || (iRRX == 0 && iRRY == 0)))
                g_bResizeAss = true;
        }
        else
            g_bResizeAss = true;
    }

    if (argc == 3 && std::wstring(argv[2]) == L"-169")
    {
        g_bAdjust169 = true;
        g_bResizeAss = true;
    }

    static const wchar_t* szArgs[] = 
    {
        L"-b", L"-u", L"-s", L"-k", L"-d", L"-f", L"-a", L"-t",
        L"-z1", L"-z2", L"-z3", L"-c1", L"-c2"
    };
    static int iArgs = sizeof(szArgs) / sizeof(const wchar_t*);

    for (int ai = 2; ai < argc; ai++)
    {
        int aj = 0;
        for (; aj < iArgs; aj++)
        {
            if (_wcsicmp(argv[ai], szArgs[aj]) == 0)
            {
                switch (aj)
                {
                case 0: g_bBracket = true; break;
                case 1: g_bUpline = true; break;
                case 2: g_bMonoline = true; break;
                case 3: g_bKeepBlankLine = true; break;
                case 4: g_bDiscardAssStyle = true; break;
                case 5: g_bUseDefaultFont = true; break;
                case 6: g_bAnimateOff = true; break;
                case 7: g_bSortTimestamp = true; break;
                case 8: g_iFontSizeIdx = 1; break;
                case 9: g_iFontSizeIdx = 2; break;
                case 10: g_iFontSizeIdx = 3; break;
                case 11: g_iEnFontClrIdx = 1; break;
                case 12: g_iEnFontClrIdx = 2; break;
                }
                break;
            }
        }
        if (!g_bCalMaxFrames && !g_bResizeAss && aj == iArgs)
        {
            wprintf(L"%s", g_szUsage.c_str());
            return 1;
        }
    }

    std::wstring strFn = argv[1];
    std::wstring strFnMain = strFn;
    std::wstring strFnExt;
    size_t nDot = strFn.find_last_of(L'.');
    if (nDot != std::wstring::npos)
    {
        strFnMain = strFn.substr(0, nDot);
        strFnExt = strFn.substr(nDot);
    }

    if (_wcsicmp(strFnExt.c_str(), L".ass") == 0)
    {
        g_bIsSrcAss = true;
    }

    std::wstring szRetMsg;
    int iRet;
    if (g_bIsSrcAss)
        iRet = ReadAss(strFn, szRetMsg);
    else
        iRet = ReadSrt(strFn, szRetMsg);

    if (iRet)
    {
        wprintf(L"%s", szRetMsg.c_str());
        return iRet;
    }

    AdjustSrt();
    UpdateMeta();

    if (g_bCalMaxFrames)
    {
        int iMF = CalMaxFrames(dFPS);
        wprintf(L"%d", iMF);
        return iMF;
    }

    if (g_bResizeAss)
    {
        std::wstring strSfnRES = strFnMain + (g_bAdjust169 ? L".169" : L".res") + L".ass";
        if (g_bAdjust169)
        {
            iRRX = g_Meta.iPlayResXSrc;
            iRRY = g_Meta.iPlayResYSrc * 3 / 4;
        }
        iRet = ResizeAss(strSfnRES, iRRX, iRRY, szRetMsg);
        wprintf(L"%s", szRetMsg.c_str());
        return iRet;
    }

    iRet = OutputSubFiles(strFnMain, szRetMsg);
    if (iRet)
    {
        wprintf(L"%s", szRetMsg.c_str());
        return iRet;
    }

    return 0;
}